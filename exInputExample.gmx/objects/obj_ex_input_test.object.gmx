<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_ex_input_test</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// IMPORTANT: Initialize exInput FIRST

// note: items in the exInput_DEMO folders are not needed for the extension to work in your game

// initialize exInput first (must be called before any ex_input_* functions are used!), you need to do this once at the start of your game
ex_input_initialize();

// turn on debug messages (note: this can impact performance with a lot of input entries! turn it off if you don't need it!)
ex_input_set_debug_mode(true);

// assign some keys and gamepad button equivalents
ex_input_create("up",     vk_up,     gp_padu);
ex_input_create("down",   vk_down,   gp_padd);
ex_input_create("left",   vk_left,   gp_padl);
ex_input_create("right",  vk_right,  gp_padr);
ex_input_create("action", ord("X"),  gp_face1);
ex_input_create("start",  vk_enter,  gp_start);
ex_input_create("back",   vk_escape, ex_input_undefined); // Use ex_input_undefined when you don't want to define a key/button equivalent

// assign some icons
ex_input_set_icons("action", 
    spr_ex_input_test_keyboard, 
    spr_ex_input_test_gamepad
);

// enable touch and set it as default input mode (touch also maps to mouse)
ex_input_set_touch_enabled(true);
ex_input_set_mode(ex_input_mode_touch);

// resize GUI layer on mobile
if (os_type == os_android || os_type == os_ios || os_type == os_winphone) {
    display_set_gui_size(display_get_width(), display_get_height());
}

// create a virtual joystick and map the directions
_joy = ex_input_virtual_joystick_create("up", "down", "left", "right", spr_virtual_joystick_knob, spr_virtual_joystick);
ex_input_virtual_joystick_set_visibility(_joy, true);
ex_input_virtual_joystick_set_region(_joy, 0, 0, display_get_gui_width(), display_get_gui_height());

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Autodetect Input Mode

// input mode will change when the user presses a keyboard key, gamepad button or on mouse/touch (if touch mode is enabled)
ex_input_set_mode_autodetect();

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check Player Input

// note: also click and drag/touch to test the joystick functionality

// check keys or gamepad buttons
if (ex_input_check("up")) {
    y-= 3;
}

if (ex_input_check("down")) {
    y+= 3;
}

if (ex_input_check("left")) {
    x-= 3;
}

if (ex_input_check("right")) {
    x+= 3;
}

// play vibration effect if using gamepad
if (ex_input_check_pressed("action")) {
    show_debug_message(" &gt;&gt; Action button pressed!");
    // note: motorLeftForce and motorRightForce is from 0.0 to 1.0
    //       syncDelta is false by default, gamepadDevice is 0 by default
    ex_input_gamepad_vibrate_start(0.5, 0.5, 45, scr_ease_out_sine);
}

// quit the game
if (ex_input_check("back")) {
    game_end();
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw test and Input Icon

draw_self();
draw_set_font(fnt_ex_input_test);
draw_set_color(c_white);

// get the icon for the action input
var _icon = ex_input_get_icon("action");

draw_text(32, 32, "Press");
draw_sprite(_icon, 0, 110, 24);
draw_text(182, 32, "to test");

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="83">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Save Input Config

// save the input data to a file
// note: password argument is optional, it can be used to encrypt the file to prevent users messing up the config data
ex_input_config_save("PlayerControls.json");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="76">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Load Input Config and Reassign

// load the input data from a file and reassign keys and gamepad buttons
// note: password argument is optional, it can be used to encrypt the file to prevent users messing up the config data
ex_input_config_load("PlayerControls.json");

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
